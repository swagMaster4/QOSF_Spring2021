# -*- coding: utf-8 -*-
"""Jyoti_Rani_Quantum_Circuit_Simulator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fjwHq_Ql220ggIeS683h_JzrtPuDxDXT
"""

# Author: Jyoti Rani 
# Checked my work using Qiskit. 

import math
import numpy as np
import random 
from collections import defaultdict 

# Create "quantum computer" with N qubits (this is actually just a vector :) )

def get_ground_state(num_qubits):
    """returns a vector of size 2**num_qubits with all zeroes except first element which is 1"""
    ground_state = np.zeros((2**num_qubits,), dtype=int)
    ground_state[0] = 1
    return ground_state

num_qubits = int(input("Please enter the number of qubits in the circuit: "))

if num_qubits > 8 or num_qubits <= 0:
  num_qubits = 3
  print("\nSorry, the number of qubits q must be greater than 0 and <= 8, because quantum behavior grows exponentially, (2^n). \nDefault value is 3 qubits. Please run the cell again to change this. ")


my_qpu = get_ground_state(num_qubits)
print("\n\nInitial ground state of my \"quantum computer\" with", num_qubits, "qubits is:", my_qpu)


#define 1 qubit gates & CNOT 

X = np.array([
[0, 1],
[1, 0]
])

Y = np.array([
[0 , -1j], 
[1j , 0]
])


Z = np.array([
[1 , 0], 
[0 , -1]
])

H = 1/np.sqrt(2) * np.array([
                             [1, 1], 
                             [1,-1]
                             ])

I = np.identity(2, dtype=int)

S = np.array([
[1, 0],
[0, math.e**((math.pi*1j)/2)]
])


T = np.array([
[1, 0],
[0, math.e**((math.pi*1j)/4)]
])


#define 2 qubit gate: CNOT 

CX = np.array([
[1, 0, 0, 0], 
[0, 1, 0, 0],
[0, 0, 0, 1],
[0, 0, 1, 0]
])


# Define projection operator |0><0|

P0x0 = np.array([
[1, 0],
[0, 0]
])

# Define projection operator |1><1|

P1x1 = np.array([
[0, 0],
[0, 1]
])


#Get parametric gate 

param1 = np.identity(num_qubits)
def get_param1(param): 
  param1 = np.array([
  [math.cos(param["theta"]/2), math.e**(1j * param["lambda"]) * math.sin(param["theta"] / 2)],
  [math.e**(1j * param["phi"]) * math.sin(param["theta"] / 2), math.e**(1j * param["lambda"] + 1j * param["phi"]) * math.cos(param["theta"] / 2)]
  ])
  return param1



print("The following quantum gates have been initialized:\nSingle qubit: X, Y, Z, H, S, T, custom parametric gate\n2 qubit: CNOT")

def iterate_operations(n, result, gate_unitary, index):
  for k in range(num_qubits-1, n, -1):
    op = I 
    if k == index:
      op = gate_unitary
    result = np.kron(op, result)
  return result



def get_operator(gate_unitary, target_qubits):
    """return unitary operator of size 2**n x 2**n for given gate and target qubits"""
    # return unitary operator of size 2**n x 2**n for given gate and target qubits
    index = target_qubits[0] -1
    result = np.array([[1]])


    #for single qubit gates 
    if len(target_qubits) == 1:
      return iterate_operations(-1, result, gate_unitary, index)
    #for CNOT, consecutive & non-consecutive cases have been split (if & else)
    elif len(target_qubits) == 2: 
      target_q = target_qubits[1] - 1
      if abs(index - target_q) == 1:
        return iterate_operations(0, result, gate_unitary, target_q)
      else:
        part1 = np.array([[1]])
        part2 = np.array([[1]])
        for k in range(num_qubits-1, -1, -1):
          op1 = I 
          op2 = I
          if k == index:
            op1 = P0x0
            op2 = P1x1
          if k == target_q:
            op2 = X
          part1 = np.kron(op1, part1)
          part2 = np.kron(op2, part2)
        return part1 + part2



def run_program(initial_state, program):
    """
    read program, and for each gate:
      - calculate matrix operator
      - multiply state with operator
    return final state
    """

    final_psi = initial_state
    for o in (program):
      if len(o) == 3: 
        matrix = get_param1(o["params"])
      else:
        matrix = o["gate"]
      operator = get_operator(matrix, o["target"])
      final_psi = np.dot(final_psi, operator)
    return final_psi

def measure_all(state_vector):
    """choose element from state_vector using weighted random and return it's index"""
    return np.random.choice(range(len(state_vector)), size = None, replace = False, p= [abs(e**2) for e in state_vector])
    
  

def get_counts(state_vector, num_shots):
    """simulate the probability of the state of our \"qubits\""""
    prob_tracker = defaultdict(list) 
    for i in range(num_shots):
      indx = measure_all(state_vector)
      key = ("{0:0" + str(num_qubits) + "b}").format(indx)
      if not prob_tracker[key]:
        prob_tracker[key] = 1
      else: 
        prob_tracker[key]+= 1
    return prob_tracker

# Define program:

my_circuit = [
{ "gate":  X, "target": [1] },
{ "gate": X, "target": [3] }, 
{ "gate": CX, "target": [1, 3] },             
{ "gate": param1, "target": [0], "params": { "theta": math.pi, "phi": (math.pi)/2, "lambda": math.pi }  } 

]


# Run circuit

final_state = run_program(my_qpu, my_circuit)
print("After running the circuit on the quantum computer, the final vector state is\n",  final_state)

# Read results

counts = get_counts(final_state, 1000)
print("\nResults are")
for key,val in counts.items():
    print("{} : {}".format(key, val))

