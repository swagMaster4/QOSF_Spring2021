# -*- coding: utf-8 -*-
"""Jyoti_Rani_Quantum_Circuit_Simulator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fjwHq_Ql220ggIeS683h_JzrtPuDxDXT
"""

import math
import numpy as np
import random 
from collections import defaultdict 


#define 1 qubit gates & CNOT 

X = np.array([
[0, 1],
[1, 0]
])

Y = np.array([
[0 , -1j], 
[1j , 0]
])


Z = np.array([
[1 , 0], 
[0 , -1]
])

H = 1/np.sqrt(2) * np.array([
                             [1, 1], 
                             [1,-1]
                             ])

I = np.identity(2, dtype=int)

S = np.array([
[1, 0],
[0, math.e**((math.pi*1j)/2)]
])


T = np.array([
[1, 0],
[0, math.e**((math.pi*1j)/4)]
])


#define 2 qubit gate: CNOT 

CX = np.array([
[1, 0, 0, 0], 
[0, 1, 0, 0],
[0, 0, 0, 1],
[0, 0, 1, 0]
])


# Define projection operator |0><0|

P0x0 = np.array([
[1, 0],
[0, 0]
])

# Define projection operator |1><1|

P1x1 = np.array([
[0, 0],
[0, 1]
])

# Create "quantum computer" with N qubits (this is actually just a vector :) )

def get_ground_state(num_qubits):
    """returns a vector of size 2**num_qubits with all zeroes except first element which is 1"""
    ground_state = np.zeros((2**num_qubits,), dtype=int)
    ground_state[0] = 1
    return ground_state

num_qubits = 3
my_qpu = get_ground_state(num_qubits)
print("Initial ground state of my \"quantum computer\" is:", my_qpu)

def get_operator(gate_unitary, target_qubits):
    """return unitary operator of size 2**n x 2**n for given gate and target qubits"""
    # return unitary operator of size 2**n x 2**n for given gate and target qubits
    index = target_qubits[0] -1
    result = np.array([[1]])

    #for single qubit gates 
    if len(target_qubits) == 1:
      for k in range(num_qubits-1, -1, -1):
        op = I 
        if k == index:
          op = gate_unitary
        result = np.kron(op, result)
      return result

    #for CNOT, consecutive & non-consecutive cases have been split 
    elif len(target_qubits) == 2: 
      target_q = target_qubits[1] - 1
      if abs(index - target_q) == 1:
        #different number of iterations --> need to condense repetitive for-loop with earlier single qubit gate for loop?
        for k in range(num_qubits-1, 0, -1):
          op = I 
          if k == target_q:
            op = gate_unitary
          result = np.kron(op, result)
        return result
      else:
        part1 = np.array([[1]])
        part2 = np.array([[1]])
        for k in range(num_qubits-1, -1, -1):
          op1 = I 
          op2 = I
          if k == index:
            op1 = P0x0
            op2 = P1x1
          if k == target_q:
            op2 = X
          part1 = np.kron(op1, part1)
          part2 = np.kron(op2, part2)
        return part1 + part2




def run_program(initial_state, program):
    """
    read program, and for each gate:
      - calculate matrix operator
      - multiply state with operator
    return final state
    """

    final_psi = initial_state
    for i in range(len(program)): 
      operator = get_operator(program[i]["gate"], program[i]["target"])
      final_psi = np.dot(final_psi, operator)
    return final_psi

def measure_all(state_vector):
    """choose element from state_vector using weighted random and return it's index"""
    return np.random.choice(range(len(state_vector)), size = None, replace = False, p= [abs(e**2) for e in state_vector])
    
  

def get_counts(state_vector, num_shots):
    """simulate the probability of the state of our \"qubits\""""
    prob_tracker = defaultdict(list) 
    for i in range(num_shots):
      indx = measure_all(state_vector)
      key = ("{0:0" + str(num_qubits) + "b}").format(indx)
      if not prob_tracker[key]:
        prob_tracker[key] = 1
      else: 
        prob_tracker[key]+= 1
    return prob_tracker

# Define program:

my_circuit = [
{ "gate": X, "target": [1] },   
{ "gate": X, "target": [3] },             
{ "gate": CX, "target": [1, 3] } 

]


# Run circuit

final_state = run_program(my_qpu, my_circuit)
print("After running the circuit on the quantum computer, the final vector state is\n",  final_state)

# Read results

counts = get_counts(final_state, 1000)
print("\nResults are")
for key,val in counts.items():
    print("{} : {}".format(key, val))

"""To check our work, we use the existing libray qiskit. Note: qiskit's notation of qubits is the opposite of our simulator. Thus, X gate on the first qubit in the code above is represented as the X gate on the last qubit in Qiskit. """

pip install qiskit

from qiskit import QuantumCircuit, Aer, execute
from math import pi
import numpy as np
from qiskit.visualization import plot_histogram

qc = QuantumCircuit(3)
# Apply X-gate to qubit 0:
qc.x(2)
# Apply X-gate to qubit 2:
qc.x(0)
# # Apply CX-gate to qubit (0,2):
qc.cx(2,0)
# # See the circuit:
qc.draw()

# Let's see the result
backend = Aer.get_backend('statevector_simulator')
final_state = execute(qc,backend).result().get_statevector()

# # In Jupyter Notebooks we can display this nicely using Latex.
# # If not using Jupyter Notebooks you may need to remove the 
# # array_to_latex function and use print(final_state) instead.
# from qiskit_textbook.tools import array_to_latex
# array_to_latex(final_state, pretext="\\text{Statevector} = ")
print(final_state)

